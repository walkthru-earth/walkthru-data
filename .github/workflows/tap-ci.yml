# Reusable Workflow for All Taps
# Uses Hetzner Cloud self-hosted runners (98% cheaper than GitHub runners)

name: Tap CI/CD

on:
  workflow_call:
    inputs:
      tap_id:
        description: 'Tap ID (e.g., re01, cl01)'
        required: true
        type: string
      server_type:
        description: 'Hetzner server type (cax11, cax21, cx22, cx32, etc.)'
        required: false
        type: string
        default: 'cax11'
      image:
        description: 'OS image (ubuntu-24.04, rocky-9, etc.)'
        required: false
        type: string
        default: 'ubuntu-24.04'
      location:
        description: 'Hetzner location (nbg1, fsn1, hel1)'
        required: false
        type: string
        default: 'nbg1'
      timeout_minutes:
        description: 'Extraction timeout'
        required: false
        type: number
        default: 30

env:
  OBJECTSTORAGE_BUCKET_NAME: walkthru-earth
  OBJECTSTORAGE_ENDPOINT: https://walkthru-earth.fsn1.your-objectstorage.com

jobs:
  create-runner:
    name: Create Hetzner Runner
    runs-on: ubuntu-latest
    outputs:
      label: ${{ steps.create.outputs.label }}
      server_id: ${{ steps.create.outputs.server_id }}
    steps:
      - name: Create Hetzner Cloud runner
        id: create
        uses: Cyclenerd/hcloud-github-runner@v1
        with:
          mode: create
          github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          name: gh-runner-${{ inputs.tap_id }}
          server_type: ${{ inputs.server_type }}
          location: ${{ inputs.location }}
          image: ${{ inputs.image }}
          # Use SSH key to disable root password and email notifications (optional)
          # ssh_key: ${{ secrets.HCLOUD_SSH_KEY_ID }}

  extract:
    name: Extract ${{ inputs.tap_id }}
    needs: create-runner
    runs-on: ${{ needs.create-runner.outputs.label }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    steps:
      - uses: actions/checkout@v4

      - name: Install DuckDB
        run: |
          # Auto-detect OS and architecture
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)

          # Map architecture names to DuckDB naming convention
          case "$ARCH" in
            x86_64|amd64) DUCKDB_ARCH="amd64" ;;
            aarch64|arm64) DUCKDB_ARCH="arm64" ;;
            *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
          esac

          echo "Detected OS: $OS, Architecture: $ARCH (DuckDB: $DUCKDB_ARCH)"

          # Download latest DuckDB CLI
          mkdir -p ~/.duckdb/bin
          LATEST_URL=$(curl -s https://api.github.com/repos/duckdb/duckdb/releases/latest | grep "browser_download_url.*duckdb_cli-${OS}-${DUCKDB_ARCH}.gz" | cut -d'"' -f4)

          if [ -z "$LATEST_URL" ]; then
            echo "Error: Could not find DuckDB release for ${OS}-${DUCKDB_ARCH}"
            exit 1
          fi

          echo "Downloading: $LATEST_URL"
          wget -q "$LATEST_URL" -O ~/.duckdb/bin/duckdb.gz
          gunzip ~/.duckdb/bin/duckdb.gz
          chmod +x ~/.duckdb/bin/duckdb
          ~/.duckdb/bin/duckdb --version
          echo ~/.duckdb/bin >> $GITHUB_PATH

      - name: Setup directories
        run: |
          mkdir -p data logs
          cd taps/${{ inputs.tap_id }}

      - name: Run extraction
        env:
          HOME: /root
          AWS_ACCESS_KEY_ID: ${{ secrets.OBJECTSTORAGE_API_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.OBJECTSTORAGE_API_SECRET }}
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Tap:      ${{ inputs.tap_id }}"
          echo "Runner:   ${{ inputs.server_type }} (${{ inputs.image }}) @ ${{ inputs.location }}"
          echo "Output:   s3://walkthru-earth/${{ inputs.tap_id }}/"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          duckdb -c ".read taps/${{ inputs.tap_id }}/extract.sql" \
            2>&1 | tee logs/${{ inputs.tap_id }}_$(date +%Y%m%d).log

      - name: Verify export
        env:
          HOME: /root
          AWS_ACCESS_KEY_ID: ${{ secrets.OBJECTSTORAGE_API_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.OBJECTSTORAGE_API_SECRET }}
        run: |
          # Check DuckLake catalog exists
          if [ ! -f "data/${{ inputs.tap_id }}.ducklake" ]; then
            echo "‚ùå Error: DuckLake catalog not created"
            exit 1
          fi

          # Show catalog summary
          echo "‚úÖ DuckLake catalog summary:"
          duckdb -c "
            ATTACH 'ducklake:sqlite:data/${{ inputs.tap_id }}.ducklake' AS lake (READ_ONLY);
            SELECT
              '${{ inputs.tap_id }}' AS tap_id,
              table_name
            FROM duckdb_tables()
            WHERE database_name = 'lake';
          "

          # Install AWS CLI for S3 uploads
          sudo apt-get update && sudo apt-get install -y unzip
          curl -s "https://awscli.amazonaws.com/awscli-exe-linux-$(uname -m).zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install
          aws --version

          # Upload catalog to tap's isolated S3 directory
          echo "üì§ Uploading catalog to s3://walkthru-earth/${{ inputs.tap_id }}/catalog.ducklake"

          aws s3 cp "data/${{ inputs.tap_id }}.ducklake" \
            "s3://walkthru-earth/${{ inputs.tap_id }}/catalog.ducklake" \
            --endpoint-url "https://fsn1.your-objectstorage.com" \
            && echo "‚úÖ Catalog uploaded successfully" \
            || echo "‚ö†Ô∏è  Catalog upload failed (will be available in artifacts)"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ inputs.tap_id }}-catalog-${{ github.run_number }}
          path: |
            data/${{ inputs.tap_id }}.ducklake
            data/catalog_*.parquet
          retention-days: 14
          compression-level: 0

  delete-runner:
    name: Delete Hetzner Runner
    needs:
      - create-runner
      - extract
    runs-on: ubuntu-latest
    if: always()  # Always clean up, even if extraction fails
    steps:
      - name: Delete Hetzner Cloud runner
        uses: Cyclenerd/hcloud-github-runner@v1
        with:
          mode: delete
          github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          name: ${{ needs.create-runner.outputs.label }}
          server_id: ${{ needs.create-runner.outputs.server_id }}
